
////////////////////////////////////////////////////////////
//   Copyright (c)  AWL Techniek
//------------------------------------------------------------
//   Routine: Step0400_ProductTakeout
//   Author: AWL\kbar
//   Created: 13-12-2018
//------------------------------------------------------------
//   Description:
//           Product takeout sequence of takeout / inlay logistic.
//
//   History:
//			First version after splitup to seperate routines
////////////////////////////////////////////////////////////

//    ___             _         _  _____     _                _   
//   | _ \_ _ ___  __| |_  _ __| ||_   _|_ _| |_____ ___ _  _| |_ 
//   |  _/ '_/ _ \/ _` | || / _|  _|| |/ _` | / / -_) _ \ || |  _|
//   |_| |_| \___/\__,_|\_,_\__|\__||_|\__,_|_\_\___\___/\_,_|\__| step 400-499
//                                                                

case diCurrentStep of
	
	400: //StepTakeoutBegin
		PartStatusInt.PartData.diProcessStatus := diStatusRangeTakeOut + 0 (*psTakeoutStarted*); // Takeout started
		if bExtRequestForSafety then
			// we cannot open the door yet, because we still have an external request for safety.
			// Even if no door is present, we don't go to the next step, to prevent the 'walk in allowed'-light from being lit.
			diCurrentStep := 1000; //StepExtSafetyBegin
			diReturnStep := 400; //StepTakeoutBegin
		else
			diCurrentStep := 1200; //StepSubOpenDoor
			diReturnStep := 405; //StepTakeoutGiveJigOrder
		end_if;

	// give order to jig to start the takeout:
	405: //StepTakeoutGiveJigOrder
		fcCmdGiveOrder(CmdGiveOrder, MailboxJigIntType.OrderSection, diOwnerID, 398); //odJigUnloadProducts
		if CmdGiveOrder.EnableOut then
			bFound := 0;
			for i := 0 to diMaxNrProducts do
				MailboxJigIntType.diProduct.[i] := PartStatusInt.PartData.bDataValid and PartStatusInt.PartData.Product[i].bDataValid;
				MailboxJigIntType.diProductNOK.[i] := PartStatusInt.PartData.bDataValid and PartStatusInt.PartData.Product[i].bDataValid and PartStatusInt.PartData.Product[i].bProcessError;
				if MailboxJigIntType.diProduct.[i] then
					bFound := 1;
				end_if;
			end_for;
			PartStatusInt.PartData.diProcessStatus := diStatusRangeTakeOut + 40 (*psTakeoutUnloadStarted*);   // Unload is started
			if (PartStatusInt.PartData.bDataValid and not PartStatusInt.PartData.bProcessInhibit and not bFound) or bOperatorHasWalkedIn then
				// the operator does not have to walk in, if we already know that there are no products to be removed from the jig
				diCurrentStep := 410; //StepTakeoutWaitJigFinished
			else
				// operator must walk in, before we continue
				diCurrentStep := 408; //StepTakeoutWaitWalkIn
			end_if;
		end_if;

	// wait until the operator walks into the light curtain:
	408: //StepTakeoutWaitWalkIn
		bMsgTktInlLightCurtainExp0 := 1;
		if not TakeOutInlayOptions.bLightCurtainPresent or not bOperatorAreaSafe
			or MachineStatus.bDryRun or MachineStatus.bSimulate
		then
			bOperatorHasWalkedIn := 1;
			diCurrentStep := 410; //StepTakeoutWaitJigFinished
		end_if;

	// wait until the takeout is completed:
	410: //StepTakeoutWaitJigFinished
		fcCmdCheckOrder(CmdCheckOrder, MailboxJigIntType.OrderSection, diOwnerID);
		if CmdCheckOrder.EnableOut then
			// jig is ready
			if MailboxJigIntType.OrderSection.diStatus = 306 (*stReadyNeedMoreNoSafe*) or MailboxJigIntType.OrderSection.diStatus = 307 (*stReadyNeedMoreWithSafe*) then
				// done, but more unload steps are needed, with or without safety
				PartStatusInt.PartData.diProcessStatus := diStatusRangeTakeOut + 15 (*psTakeoutReleasePrep*);     // Back to prepare for unload
				diCurrentStep := 300; //StepRelTakeoutBegin
			else
				// done, no more steps are needed
				PartStatusInt.PartData.diProcessStatus := diStatusRangeTakeOut + 50 (*psTakeoutUnloadReady*);     // Unload is finished
				diCurrentStep := 420; //StepTakeoutBatchCounter
			end_if;
		elsif bExtRequestForSafety then
			// external request for safety. The operator can now push the start button, to honour the safety request.
			// OR he can simply continue the takeout. When all parts are taken out, we will leave this step.
			diStartButtonOrder := 26; //odWaitForKeyPressMimic
			if MailboxStartButtonInt.OrderSection.diOwner = diOwnerID and
			(
				MailboxStartButtonInt.OrderSection.diStatus = 20 //stShortPressSeen
				or MailboxStartButtonInt.OrderSection.diStatus = 21 //stLongPressActive
				or MailboxStartButtonInt.OrderSection.diStatus = 22 //stLongPressSeen
			) then
				diCurrentStep := 1005; //StepExtSafetyCloseDoor
				diReturnStep := 410; //StepTakeoutWaitJigFinished
			end_if;
		end_if;

	// update the batch counters, if present:
	420: //StepTakeoutBatchCounter
		if TakeOutInlayOptions.bUseBatchCounter then
			diProductNr := 0; // start before the first product (the increment in the next step will make it start at 1)
			diCurrentStep := 425; //StepTakeoutBatchCntrLoop
		else
			diCurrentStep := 450; //StepTakeoutBatchCntrDone
		end_if;

	// loop through all products
	425: //StepTakeoutBatchCntrLoop
		diProductNr := diProductNr + 1;
		if diProductNr > diMaxNrProducts then
			// done
			diCurrentStep := 450; //StepTakeoutBatchCntrDone
		// Only count products present and OK
		elsif PartStatusInt.PartData.Product[diProductNr].bDataValid and not PartStatusInt.PartData.Product[diProductNr].bProcessError then
			diBatchCounter := PartStatusInt.PartData.Product[diProductNr].diBatchCounter;
			if diBatchCounter > 0 and diBatchCounter <= diMaxBatchCounters then
				// this product is present, and it is assigned to a batch counter. Increment that counter:
				dbBatchCounter.BatchData[diBatchCounter].diBatchParts := dbBatchCounter.BatchData[diBatchCounter].diBatchParts + 1;
				// check if we must generate a message:
				if dbBatchCounter.BatchData[diBatchCounter].diBatchEnd > 0
					and dbBatchCounter.BatchData[diBatchCounter].diBatchParts >= dbBatchCounter.BatchData[diBatchCounter].diBatchEnd
				then
					// end value reached or exceeded!
					diCurrentStep := 430; //StepTakeoutBatchCntrEndVal

				elsif dbBatchCounter.BatchData[diBatchCounter].diBatchWarning > 0
					and dbBatchCounter.BatchData[diBatchCounter].diBatchParts = dbBatchCounter.BatchData[diBatchCounter].diBatchWarning
				then
					// warning value reached!
					diCurrentStep := 440; //StepTakeoutBatchCntrWarn
				end_if;
			end_if;
		end_if;

	430: //StepTakeoutBatchCntrEndVal
		// Ensure to only try and give a pop-up once per scan. If tried and failed, try again next scan.
		if diPopupTriedInScan <> diScanCounter then
			// end value reached or exceeded! show the corresponding message:
			MailboxPopupIntType.diRegisteredPopupNrs := MailboxPopupIntType.diRegisteredPopupNrs + 1;
			diPopupTriedInScan := diScanCounter;
			if MailboxPopupIntType.diRegisteredPopupNrs = MailboxPopupIntType.diAllowedPopupNr then
				fcCmdGiveOrder(CmdGiveOrder, MailboxPopupIntType.OrderSection, diOwnerID, 700); //odShow
				if CmdGiveOrder.EnableOut then
					MailboxPopupIntType.diTextNr := 501; //diTextNrBatchCountEnd
					MailboxPopupIntType.diIconNr := 4; //iPopupIconSuccess
					MailboxPopupIntType.diAssociatedValue1 := diBatchCounter; // associated value 1: batch counter number
					MailboxPopupIntType.Bits.bButton1Visible := 1; // ok button
					MailboxPopupIntType.Bits.bButton2Visible := 0;
					MailboxPopupIntType.Bits.bButton3Visible := 0;
					MailboxPopupIntType.Bits.bButton4Visible := 0;
					MailboxPopupIntType.OrderSection.diStatus := 0; //stNotInitialized
					diCurrentStep := 435; //StepTakeoutBatchCntrEndChk
				end_if;
			end_if;
		end_if;

	435: //StepTakeoutBatchCntrEndChk
		// wait until the popup has gone away:
		if MailboxPopupIntType.OrderSection.diOwner = diOwnerID then
			fcCmdCheckOrder(CmdCheckOrder, MailboxPopupIntType.OrderSection, diOwnerID);
			if CmdCheckOrder.EnableOut then
				MailboxPopupIntType.OrderSection.diOwner := 0; //OwnerNobody
				dbBatchCounter.BatchData[diBatchCounter].diBatchParts := 0; // reset counter
				diCurrentStep := 425; //StepTakeoutBatchCntrLoop; // continue with the rest of the product
			end_if;
		else
			// popup 'stolen', try to ask the question again
			diCurrentStep := 430; //StepTakeoutBatchCntrEndVal
		end_if;

	440: //StepTakeoutBatchCntrWarn
		// warning value reached. show the corresponding message:
		if diPopupTriedInScan <> diScanCounter then
			MailboxPopupIntType.diRegisteredPopupNrs := MailboxPopupIntType.diRegisteredPopupNrs + 1;
			diPopupTriedInScan := diScanCounter;
			if MailboxPopupIntType.diRegisteredPopupNrs = MailboxPopupIntType.diAllowedPopupNr then
				fcCmdGiveOrder(CmdGiveOrder, MailboxPopupIntType.OrderSection, diOwnerID, 700); //odShow
				if CmdGiveOrder.EnableOut then
					MailboxPopupIntType.diTextNr := 500; //diTextNrBatchCountWarn
					MailboxPopupIntType.diIconNr := 3; //iPopupIconInfo
					MailboxPopupIntType.diAssociatedValue1 := diBatchCounter; // associated value Int 1: batch counter number
					MailboxPopupIntType.Bits.bButton1Visible := 1; // ok button
					MailboxPopupIntType.Bits.bButton2Visible := 0;
					MailboxPopupIntType.Bits.bButton3Visible := 0;
					MailboxPopupIntType.Bits.bButton4Visible := 0;
					MailboxPopupIntType.OrderSection.diStatus := 0; //stNotInitialized
					MailboxPopupIntType.OrderSection.diOwner := 0; //OwnerNobody; // release the mailbox owner immediately, so we can continue (we don't wait on this message)
					diCurrentStep := 425 (*StepTakeoutBatchCntrLoop*); // continue with the rest of the products
				end_if;
			end_if;
		end_if;

	450: //StepTakeoutBatchCntrDone
		// continue with prepare for inlay:
		diCurrentStep := 500; //StepPrepInlayBegin

end_case;